{"meta":{"title":"Jason Rao's Blog","subtitle":"态度决定一切 细节决定成败","description":"饶扬胜,饶扬胜博客,架构师博客,全栈技术,分布式架构,Jason Rao,raoyangsheng","author":"Jason Rao","url":"https://raoyangsheng.com"},"pages":[{"title":"关于作者","date":"2019-05-28T01:00:00.000Z","updated":"2019-12-05T06:12:56.157Z","comments":true,"path":"about/index.html","permalink":"https://raoyangsheng.com/about/index.html","excerpt":"","text":"个人信息 姓名/性别/出生日期 本科/xxx计算机系xxx专业/英语六级 技术博客：http://snailclimb.top/ 荣誉奖励：获得了什么奖（获奖时间） Github：https://github.com/Snailclimb Github Resume: http://resume.github.io/?Snailclimb 期望职位：Java 研发程序员/大数据工程师(Java后台开发为首选) 期望城市：xxx城市 项目经历xxx项目项目描述介绍该项目是做什么的、使用到了什么技术以及你对项目整体设计的一个感受 责任描述主要可以从下面三点来写： 在这个项目中你负责了什么、做了什么、担任了什么角色 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用 另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。 开源项目和技术文章开源项目 Java-Guide ：一份涵盖大部分Java程序员所需要掌握的核心知识。Star:3.9K; Fork:0.9k。 技术文章推荐 可能是把Java内存区域讲的最清楚的一篇文章 搞定JVM垃圾回收就是这么简单 前端&amp;后端程序员必备的Linux基础知识 可能是把Docker的概念讲的最清楚的一篇文章 校园经历（可选）2016-2017担任学校社团-致深社副会长，主要负责团队每周活动的组建以及每周例会的主持。 2017-2018 担任学校传媒组织：“长江大学在线信息传媒”的副站长以及安卓组成员。主要负责每周例会主持、活动策划以及学校校园通APP的研发工作。 技能清单以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 自我评价（可选）自我发挥。切记不要过度自夸！！！ 感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"categories","date":"2018-10-11T09:13:47.000Z","updated":"2019-12-05T06:12:56.157Z","comments":false,"path":"categories/index.html","permalink":"https://raoyangsheng.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-11T09:13:24.000Z","updated":"2019-12-05T06:12:56.159Z","comments":false,"path":"tags/index.html","permalink":"https://raoyangsheng.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何让Python pip使用国内镜像体验飞一样的速度","slug":"it-python-01","date":"2018-09-01T11:25:49.000Z","updated":"2019-12-05T06:12:56.155Z","comments":true,"path":"2018/09/it-python-01.html","link":"","permalink":"https://raoyangsheng.com/2018/09/it-python-01.html","excerpt":"","text":"相信大家在使用pip安装依赖包时很头疼，下载的网速超级慢，那是因为使用pip install命令时默认使用国外的源：https://files.pythonhosted.org，不妨ping一下，是美国的IP. 第1步：默认国外源：1234567891011如下命令：(venv) iMac:20180921-demo raoys$ pip3 install --upgrade pipCollecting pip Downloading https://files.pythonhosted.org/packages/5f/25/ e52d3f31441505a5f3af41213346e5b6c221c9e086a166f3703d2ddaf940/pip-18.0-py2.py3-none-any.whl (1.3MB) 100% |████████████████████████████████| 1.3MB 556kB/s Installing collected packages: pip Found existing installation: pip 10.0.1 Uninstalling pip-10.0.1: Successfully uninstalled pip-10.0.1Successfully installed pip-18.0 下面教大家如何国内的源，体验飞的速度！！！ 第2步：介绍有哪些国内源： 12345678910111213清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/需要注意的是新版ubuntu要求使用https源。 第3步：开始使用国内源： A、临时使用：可以在使用pip的时候加参数“-i https://pypi.tuna.tsinghua.edu.cn/simple” 例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests，这样就会从清华这边的镜像去安装requests库。 1234567891011121314151617181920212223242526(venv) iMac:20180921-demo raoys$ pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requestsLooking in indexes: https://pypi.tuna.tsinghua.edu.cn/simpleCollecting requests Downloading https://pypi.tuna.tsinghua.edu.cn/packages/65/47 /7e02164a2a3db50ed6d8a6ab1d6d60b69c4c3fdf57a284257925dfc12bda/requests-2.19.1-py2.py3-none-any.whl (91kB) 100% |████████████████████████████████| 92kB 1.4MB/s Collecting urllib3&lt;1.24,&gt;=1.21.1 (from requests) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/bd/c9 /6fdd990019071a4a32a5e7cb78a1d92c53851ef4f56f62a3486e6a7d8ffb/urllib3-1.23-py2.py3-none-any.whl (133kB) 100% |████████████████████████████████| 143kB 399kB/s Collecting chardet&lt;3.1.0,&gt;=3.0.2 (from requests) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/bc/a9 /01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB) 100% |████████████████████████████████| 143kB 2.1MB/s Collecting idna&lt;2.8,&gt;=2.5 (from requests) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/4b/2a /0276479a4b3caeb8a8c1af2f8e4355746a97fab05a372e4a2c6a6b876165/idna-2.7-py2.py3-none-any.whl (58kB) 100% |████████████████████████████████| 61kB 2.2MB/s Collecting certifi&gt;=2017.4.17 (from requests) Downloading https://pypi.tuna.tsinghua.edu.cn/packages/df/f7 /04fee6ac349e915b82171f8e23cee63644d83663b34c539f7a09aed18f9e/certifi-2018.8.24-py2.py3-none-any.whl (147kB) 100% |████████████████████████████████| 153kB 1.9MB/s Installing collected packages: urllib3, chardet, idna, certifi, requestsSuccessfully installed certifi-2018.8.24 chardet-3.0.4 idna-2.7 requests-2.19.1 urllib3-1.23(venv) iMac:20180921-demo raoys$ B、永久修改，一劳永逸：123456789Linux: 修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)MacOS: 修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)windows:，直接在user目录中创建一个pip目录，再新建文件pip.ini。例如：C:\\Users\\jason\\pip\\pip.ini内容如下：[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com C、配置后直接使用pip instal命令即可，无需加任何参数，如下命令：12345678910111213(venv) iMac:20180921-demo raoys$ cd ~(venv) iMac:~ raoys$ mkdir .pip(venv) iMac:~ raoys$ cd .pip/(venv) iMac:.pip raoys$ vi pip.conf(venv) iMac:.pip raoys$ pip3 install beautifulsoup4Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simpleCollecting beautifulsoup4 Downloading https://pypi.tuna.tsinghua.edu.cn/packages/21/0a /47fdf541c97fd9b6a610cb5fd518175308a7cc60569962e776ac52420387/beautifulsoup4-4.6.3-py3-none-any.whl (90kB) 100% |████████████████████████████████| 92kB 1.3MB/s Installing collected packages: beautifulsoup4Successfully installed beautifulsoup4-4.6.3(venv) iMac:.pip raoys$ 以上就是pip使用国内源的所有步骤。","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://raoyangsheng.com/tags/Python/"}]},{"title":"git remote: HTTP Basic: Access denied 错误解决办法","slug":"it-git-02","date":"2017-10-13T14:13:13.000Z","updated":"2019-12-05T06:12:56.151Z","comments":true,"path":"2017/10/it-git-02.html","link":"","permalink":"https://raoyangsheng.com/2017/10/it-git-02.html","excerpt":"","text":"问题描述 git push or git clone 报 HTTP Basic: Access denied 错误 原因本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致。 解决方案12345671. 如果账号密码有变动 用这个命令： git config –-system –-unset credential.helper 然后重新输入账号密码 应该就能解决了； 2. 如果用了第一个命令 还不能解决问题那么 用这个命令： git config –-global http.emptyAuth true","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://raoyangsheng.com/tags/Git/"}]},{"title":"Redis工具类对各种数据类型的操作","slug":"it-redis-01","date":"2017-10-13T13:04:22.000Z","updated":"2019-12-05T06:12:56.156Z","comments":true,"path":"2017/10/it-redis-01.html","link":"","permalink":"https://raoyangsheng.com/2017/10/it-redis-01.html","excerpt":"","text":"Redis工具类对string，list，hash，set，zset数据类型的操作。 添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; Redis代码配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.*; /** * * Redis模板配置，缓存配置 */ @Configuration@EnableCachingpublic class RedisConfig &#123; @Autowired RedisConnectionFactory redisConnectionFactory; /** * 实例化 RedisTemplate 对象 */ @Bean public RedisTemplate&lt;String, Object&gt; functionDomainRedisTemplate() &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;(); initDomainRedisTemplate(redisTemplate, redisConnectionFactory); return redisTemplate; &#125; /** * 设置数据存入 redis 的序列化方式 */ private void initDomainRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate, RedisConnectionFactory factory) &#123; /*** redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer(Object.class)); */ redisTemplate.setConnectionFactory(factory); &#125; /** * 实例化 HashOperations 对象,可以使用 Hash 类型操作 */ @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForHash(); &#125; /** * 实例化 ValueOperations 对象,可以使用 String 操作 */ @Bean public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForValue(); &#125; /** * 实例化 ListOperations 对象,可以使用 List 操作 */ @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForList(); &#125; /** * 实例化 SetOperations 对象,可以使用 Set 操作 */ @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForSet(); &#125; /** * 实例化 ZSetOperations 对象,可以使用 ZSet 操作 */ @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForZSet(); &#125; &#125; Redis操作代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.*;import org.springframework.stereotype.Service; import javax.annotation.Resource;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit; @Servicepublic class RedisService &#123; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; // HashMap操作 @Resource private HashOperations&lt;String, String, Object&gt; hashOperations; // Object操作 @Resource private ValueOperations&lt;String, Object&gt; valueOperations; // List操作 @Resource private ListOperations&lt;String, Object&gt; listOperations; // set操作 @Resource private SetOperations&lt;String, Object&gt; setOperations; // ZSet操作 @Resource private ZSetOperations&lt;String, Object&gt; zSetOperations; //--------------------------------------------------------------------- // redisTemplate //--------------------------------------------------------------------- /** * 判断key是否存在 * @param key */ public boolean hasKey(String key) &#123; return redisTemplate.hasKey(key); &#125; /** * 删除key * @param key */ public void delete(String key)&#123; redisTemplate.delete(key); &#125; /** * 判断指定key的hashKey是否存在 * @param key * @param hashKey * @return */ public boolean hasKey(String key, String hashKey) &#123; return redisTemplate.opsForHash().hasKey(key, hashKey); &#125; /** * 设置超时时间 * @param key * @param timeout * @param unit */ public void expire(String key, final long timeout, final TimeUnit unit) &#123; redisTemplate.expire(key, timeout, unit); &#125; /** * 获取过期时间 * @param key * @return */ public long ttl(String key)&#123; return redisTemplate.getExpire(key); &#125; /** * 获取指定pattern的key * @param pattern * @return */ public Set&lt;String&gt; keys(String pattern) &#123; return redisTemplate.keys(pattern); &#125; /** * 删除多个key * @param keys */ public void delete(Set&lt;String&gt; keys) &#123; redisTemplate.delete(keys); &#125; /** * 设置过期时间 * @param key * @param expire */ private void setExpire (String key,long expire)&#123; if (expire != -1) &#123; redisTemplate.expire(key, expire, TimeUnit.SECONDS); &#125; &#125; //--------------------------------------------------------------------- // ValueOperations -&gt; Redis String/Value 操作 //--------------------------------------------------------------------- /** * 设置key-value值 */ public void addValue(String key, Object value,long expire)&#123; valueOperations.set(key, value); setExpire(key,expire); &#125; /** * 设置key-value值,传入时间单位 */ public void addValue(String key, Object value,long expire, TimeUnit timeUnit)&#123; valueOperations.set(key, value, expire, timeUnit); &#125; /** * 设置key-value值, 无过期时间 */ public void addValue(String key, Object value)&#123; valueOperations.set(key, value); &#125; /** * 获取key的值 * */ public Object getValue(String key)&#123; return valueOperations.get(key); &#125; //--------------------------------------------------------------------- // HashOperations -&gt; Redis Redis Hash 操作 //--------------------------------------------------------------------- /** * 向redis 中添加内容 * @param key 保存key * @param hashKey hashKey * @param data 保存对象 data * @param expire 过期时间 -1：表示不过期 */ public void addHashValue(String key,String hashKey, Object data, long expire) &#123; hashOperations.put(key, hashKey, data); setExpire(key,expire); &#125; /** * Hash 添加数据 * @param key key * @param map data */ public void addAllHashValue(String key, Map&lt;String, Object&gt; map, long expire) &#123; hashOperations.putAll(key, map); setExpire(key,expire); &#125; /** * 删除hash key * @param key key * @param hashKey hashKey */ public long deleteHashValue(String key, String hashKey) &#123; return hashOperations.delete(key, hashKey); &#125; /** * 获取数据 */ public Object getHashValue(String key, String hashKey) &#123; return hashOperations.get(key, hashKey); &#125; /** * 批量获取数据 */ public List&lt;Object&gt; getHashAllValue(String key) &#123; return hashOperations.values(key); &#125; /** * 批量获取指定hashKey的数据 */ public List&lt;Object&gt; getHashMultiValue(String key, List&lt;String&gt; hashKeys) &#123; return hashOperations.multiGet(key, hashKeys); &#125; /** * 获取hash数量 */ public Long getHashCount(String key) &#123; return hashOperations.size(key); &#125; //--------------------------------------------------------------------- // ZSetOperations -&gt; Redis Sort Set 操作 //--------------------------------------------------------------------- /** * 设置zset值 */ public boolean addZSetValue(String key, Object member, long score)&#123; return zSetOperations.add(key, member, score); &#125; /** * 设置zset值 */ public boolean addZSetValue(String key, Object member, double score)&#123; return zSetOperations.add(key, member, score); &#125; /** * 批量设置zset值 */ public long addBatchZSetValue(String key, Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples)&#123; return zSetOperations.add(key, tuples); &#125; /** * 自增zset值 */ public void incZSetValue(String key, String member, long delta)&#123; zSetOperations.incrementScore(key, member, delta); &#125; /** * 获取zset数量 */ public long getZSetScore(String key, String member)&#123; Double score = zSetOperations.score(key, member); if(score==null)&#123; return 0; &#125;else&#123; return score.longValue(); &#125; &#125; /** * 获取有序集 key 中成员 member 的排名 。其中有序集成员按 score 值递减 (从小到大) 排序。 */ public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetRank(String key, long start, long end)&#123; return zSetOperations.rangeWithScores(key, start, end); &#125; //--------------------------------------------------------------------- // listOperations -&gt; Redis List() 操作 //--------------------------------------------------------------------- /** * 添加list列表 */ public void addListValue(String key,Object list)&#123; listOperations.leftPush(key,list); &#125; /** * 获取指定Key对应的list */ public Object getListValue(String key)&#123; return listOperations.leftPop(key); &#125; //--------------------------------------------------------------------- // setOperations -&gt; Redis Set() 操作 //--------------------------------------------------------------------- /** * 添加Set集合集合 */ public void addSetValue(String key,Object list)&#123; setOperations.add(key,list); &#125; /** * 获取指定Key对应的set */ public Object getSetValue(String key)&#123; return setOperations.members(key); &#125; /** * 获取并移除指定key的值 */ public Object popSetValue(String key)&#123; return setOperations.pop(key); &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://raoyangsheng.com/tags/Redis/"}]},{"title":"Git常用命令列表","slug":"it-git-01","date":"2017-10-12T14:13:13.000Z","updated":"2019-12-05T06:12:56.151Z","comments":true,"path":"2017/10/it-git-01.html","link":"","permalink":"https://raoyangsheng.com/2017/10/it-git-01.html","excerpt":"","text":"Git常用命令整理： 根据多个项目实践整理下面的git命令大全，留着后续使用。 仓库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] $ git checkout -b [local branch] [remote branch] eg: $ git checkout -b v1.0 origin/v1.0 # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://raoyangsheng.com/tags/Git/"}]},{"title":"Nginx负载均衡之权重配置","slug":"it-server-nginx-02","date":"2017-08-02T10:17:35.000Z","updated":"2019-12-05T06:12:56.156Z","comments":true,"path":"2017/08/it-server-nginx-02.html","link":"","permalink":"https://raoyangsheng.com/2017/08/it-server-nginx-02.html","excerpt":"","text":"Nginx负载均衡之权重配置 配置如下：123456789101112131415161718192021222324252627282930313233user www www; ##nginx以www用户身份运行，需要建立www用户worker_processes 1; ##工作进程，一般设置为auto自动#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; use epoll; worker_connections 65535; ##线程，并且在系统中给到比他大的线程&#125;http &#123; upstream aabbccdd&#123; ##算法 server 192.168.1.201:80 weight=2; ##监控server的80端口，weigh为权重，2每访问两次，3访问一词 server 192.168.1.201:80 weight=2;&#125;include mime.types;server &#123; ##设置虚拟主机 listen 80; server_name www.aabbccdd.com; location / &#123; 调度算法 proxy_pass http://aabbccdd; ## 与上面upstream 配置的名称一致. &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"https://raoyangsheng.com/categories/服务器/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://raoyangsheng.com/tags/Nginx/"}]},{"title":"Nginx监听一个端口多域名转发配置","slug":"it-server-nginx-01","date":"2017-08-01T10:55:35.000Z","updated":"2019-12-05T06:12:56.156Z","comments":true,"path":"2017/08/it-server-nginx-01.html","link":"","permalink":"https://raoyangsheng.com/2017/08/it-server-nginx-01.html","excerpt":"","text":"Nginx监听一个端口多域名转发配置方法 配置如下：worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name 192.168.1.x; error_page 404 401 400 /400.html; location / { root html; index 400.html; } location = /40x.html{ root html; } } server { listen 80; server_name test1.com.cn www.test1.com.cn; location / { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; root html; index index.html index.htm; } } server { listen 80; server_name test2.com www.test2.com; location / { proxy_pass http://localhost:8081; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; root html; index index.html index.htm; } } }","categories":[{"name":"服务器","slug":"服务器","permalink":"https://raoyangsheng.com/categories/服务器/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://raoyangsheng.com/tags/Nginx/"}]},{"title":"VMware中CentOS7静态IP的设置","slug":"it-linux-centos-02","date":"2015-10-12T22:33:23.000Z","updated":"2019-12-05T06:12:56.155Z","comments":true,"path":"2015/10/it-linux-centos-02.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-linux-centos-02.html","excerpt":"","text":"VMware中CentOS7系统设置静态IP的步骤 VMware下有三种网络连接模式一、birdged（桥接）桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。 二、NAT(网络地址转换)NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在VMware提供的一个虚拟网络。 三、Host-only(仅主机)在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。 这里主要讨论桥接和NAT模式 NAT和桥接的比较(1) NAT模式和桥接模式虚拟机都可以上外网。(2) 由于NAT的网络在VMware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。 步骤1 在虚拟机中使用NAT如图： 接下来看看在NAT模式下，进入到CentOS7系统后，该如何为其配置网络： 步骤2 查看宿主机（本机）的默认网关如图： 上图为公司内外，默认网关为：10.0.0.1 步骤3 配置VMware的NAT模式设置如图： 步骤4 进入centos7系统，执行如下命令修改网络配置1vi /etc/sysconfig/network-scripts/ifcfg-ens33 12345678910111213141516171819TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 静态IPDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=ab60eed1-2349-495d-a33d-2a96c4f8cbb3DEVICE=ens33ONBOOT=yes #随系统启动IPADDR=10.0.100.100 #设置固定IPNETMASK=255.255.255.0 GATEWAY=10.0.100.2 #第二步中 NAT设置中的网关IPDNS1=119.29.29.29 #DNSIP，基本上通用 保存后重启网络服务，执行如下命令：1systemctl restart network.service 步骤5 最后验证网络配置是否成功1ping baidu.com 结果如图： 如上图ping通了，就说明NAT模式下的网络配置成功了！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://raoyangsheng.com/tags/CentOS/"},{"name":"VMware","slug":"VMware","permalink":"https://raoyangsheng.com/tags/VMware/"}]},{"title":"CentOS开机网络启动设置问题","slug":"it-linux-centos-01","date":"2015-10-12T12:11:23.000Z","updated":"2019-12-05T06:12:56.154Z","comments":true,"path":"2015/10/it-linux-centos-01.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-linux-centos-01.html","excerpt":"","text":"最新安装的CentOS系统，开机总是需要重新设置网络eth0，才能上网，现在下面做了一下设置，就可以开机后自己联网。 步骤如下：1234561，输入命令ifconfig，检查eth0设备网络是否没有启动；2，如果手动启动，输入命令ifup eth0即可；3，如果需要开机后自启动网络，则需要在文件 /etc/rc.local 里加入 /sbin/ifup eth0 ，这样重新启动，问题就解决了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://raoyangsheng.com/tags/CentOS/"}]},{"title":"Java并行计算方案","slug":"it-java-calc-forkjoin","date":"2015-10-12T07:12:27.000Z","updated":"2019-12-05T06:12:56.152Z","comments":true,"path":"2015/10/it-java-calc-forkjoin.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-java-calc-forkjoin.html","excerpt":"","text":"a、ForkJoin描述： ForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。 fork是分解的意思, join是收集的意思. 它非常类似于HADOOP提供的MapReduce框架，只是MapReduce的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin更加类似于单机版的MapReduce。 b、注意事项： 在fork/join框架中，若某个子问题由于等待另一个子问题的完成而无法继续执行。那么处理该子问题的线程会主动寻找其他尚未运行完成的子问题来执行。这种方式减少了线程的等待时间，提高了性能。子问题中应该避免使用synchronized关键词或其他方式方式的同步。也不应该是一阻塞IO或过多的访问共享变量。在理想情况下，每个子问题的实现中都应该只进行CPU相关的计算，并且只适用每个问题的内部对象。唯一的同步应该只发生在子问题和创建它的父问题之间。 c、Fork/Join使用两个类完成以上两件事情： ForkJoinTask: 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join的操作机制，ForkJoinTask实现了Future接口，可以按照Future接口的方式来使用。在ForkJoinTask类中之重要的两个方法fork和join。fork方法用以一部方式启动任务的执行，join方法则等待任务完成并返回指向结果。在创建自己的任务是，最好不要直接继承自ForkJoinTask类，而要继承自ForkJoinTask类的子类RecurisiveTask或RecurisiveAction类。1. RecursiveAction，用于没有返回结果的任务2. RecursiveTask，用于有返回值的任务 ForkJoinPool：task要通过ForkJoinPool来执行，分割的子任务也会添加到当前工作线程的双端队列中，进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务。 2个构造方法 12ForkJoinPool(int parallelism) 创建一个包含parallelism个并行线程的ForkJoinPool。ForkJoinPool() 以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool。 3种方式启动 123异步执行 execute(ForkJoinTask) ForkJoinTask.fork等待获取结果 invoke(ForkJoinTask) ForkJoinTask.invoke执行,获取Future submit(ForkJoinTask) ForkJoinTask.fork(ForkJoinTask are Futures) d、异常处理: ： ForkJoinTask在执行的时候可能会抛出异常，但是没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常. getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。 123if(task.isCompletedAbnormally()) &#123; System.out.println(task.getException());&#125; e、代码展示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.concurrent.ForkJoinPoolimport java.util.concurrent.ForkJoinTaskimport java.util.concurrent.RecursiveTask/** * fork * 对一个大数组进行并行求和的RecursiveTask * * 大任务可以拆成小任务，小任务还可以继续拆成更小的任务，最后把任务的结果汇总合并，得到最终结果，这种模型就是Fork/Join模型。 Java7引入了Fork/Join框架，我们通过RecursiveTask这个类就可以方便地实现Fork/Join模式。 * Created by wenbronk on 2017/7/13. */class ForkJoinTest extends RecursiveTask&lt;Long&gt; &#123; static final int THRESHOLD = 100 long[] array int start int end ForkJoinTest(long[] array, int start, int end) &#123; this.start = start this.end = end this.array = array &#125; @Override protected Long compute() &#123; if (end - start &lt; THRESHOLD) &#123; long sum = 0 for (int i = start; i &lt; end; i++) &#123; sum += array[i] &#125; try &#123; Thread.sleep(100) &#125; catch (Exception e) &#123; e.printStackTrace() &#125; println String.format(&apos;compute %d %d = %d&apos;, start, end, sum) &#125; // 对于大任务, 分多线程执行 int middle = (end + start) / 2 println String.format(&apos;split %d %d =&gt; %d %d, %d %d&apos;, start, end, start, middle, middle, end) def subtask1 = new ForkJoinTest(this.array, start, middle); def subtask2 = new ForkJoinTest(this.array, middle, end); invokeAll(subtask1, subtask2) Long subresult1 = subtask1.join() Long subresult2 = subtask2.join() Long result = subresult1 + subresult2 System.out.println(&quot;result = &quot; + subresult1 + &quot; + &quot; + subresult2 + &quot; ==&gt; &quot; + result); return result &#125; public static void main(String[] args) throws Exception &#123; // 创建随机数组成的数组: long[] array = new long[400];// fillRandom(array); // fork/join task: ForkJoinPool fjp = new ForkJoinPool(4); // 最大并发数4 ForkJoinTask&lt;Long&gt; task = new ForkJoinTest(array, 0, array.length); long startTime = System.currentTimeMillis(); Long result = fjp.invoke(task); long endTime = System.currentTimeMillis(); System.out.println(&quot;Fork/join sum: &quot; + result + &quot; in &quot; + (endTime - startTime) + &quot; ms.&quot;); &#125;&#125; f、java代码的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.doordu.pingan.demo;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;/** * forkjoin的简单易用 * Created by wenbronk on 2017/7/26. */public class CountTask extends RecursiveTask&lt;Integer&gt;&#123; private volatile static int count = 0; private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; public static final int threadhold = 2; @Override protected Integer compute() &#123; int sum = 0; System.out.println(&quot;开启了一条线程单独干: &quot; + count++); // 如果任务足够小, 就直接执行 boolean canCompute = (end - start) &lt;= threadhold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125;else &#123; //任务大于阈值, 分裂为2个任务 int middle = (start + end) / 2; CountTask countTask1 = new CountTask(start, middle); CountTask countTask2 = new CountTask(middle + 1, end); // 开启线程// countTask1.fork();// countTask2.fork(); invokeAll(countTask1, countTask2); Integer join1 = countTask1.join(); Integer join2 = countTask2.join(); // 结果合并 sum = join1 + join2; &#125; return sum; &#125; // 测试 public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); CountTask countTask = new CountTask(1, 100); ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(countTask); System.out.println(result.get()); &#125;&#125; g、work-stealing g-1 forkjoin 框架是有 work-steal 机制的，这个机制主要功能是：“空闲的” worker thread 从其它 worker thread 的 workQueue 里取得“未执行”的 task 然后执行。 g-2 具体细节机制如下： 123456789101、每个 worker thread 维护自己的 scheduling 队列中的“可运行的”task - 队列是一个双向队列（称作：deques），支持 LIFO 和 FIFO 操作。2、在task 中生成的“子task”，会被放进生成它的 task 所在的 worker thread 的 双向队列。3、worker thread 处理双向队列中的 task 时，使用的是 LIFO 规则（最后进来的，最先被处理）4、当worker thread 的队列时没有任务可执行时，它会随机地偷取别的 worker thread 的 work queue 里的 task，然后执行它。在偷取时，使用的是 FIFO 规则，即偷取别人队列里“最先进入”队列的 task。5、当 worker thread 执行时，遇到了一个join操作（例如：newTask.join），它会暂停当前的 task 的处理，而来处理这个join操作所要执行的任务内容。直到这个join操作的任务执行完后，才会返回刚才暂停任务，继续执行被暂停任务的其它内容。所有 task 都会在不进行“阻塞”情况下完成。 （这里的“阻塞”的意思，个人理解为不是IO操作的那种阻塞，而是在任务调试时，没有具体的“阻塞”处理（例如：ArrayBlockingQueue的那种阻塞），或是没有用“阻塞的方式”进行任务调度）之前以为每次调用 fork 方法，都会生成一个线程，看了源码和进行Debug后才知道：根据构造函数中的parallelism值来，决定是否启动新线程。 在 fork 方法中，((ForkJoinWorkerThread)t).workQueue.push(this)这语句会把任务加到“当前线程的workQueue”里，进行排队。然后调用signalWork方法，来看是否还可以启动新线程来处理“未分配任务”。如果可以，就启动新线程处理任务。 12当 worker thread 没有要执行的 task 或者偷取任务失败时，就会进行暂时等待处理（通过yield，sleep，或者调整优先度等方式），过一段时间再重试看看有没有任务可以执行。如果所有的 worker thread 都处于闲置状态， 等待上层的发送 task 过来的话，就不会进行重试（看是否有任务可以执行）。 g-3 work-stealing的“LIFO和FIFO”处理方式有两点好处： 12341、减少了取 task 时的竞争。worker thread 在执行自己队列任务时，是使用从尾部取。别人从它的队列里偷取任务时，是从队列头部取。所以减少了取时的竞争。2、被偷取的任务，一般都是最早入队列的任务。这种任务一般来说，都是非常大的任务，是那种需要进行递归分析的的大任务，而不是那种分解完的小任务。所以，减少了任务偷取的次数。 （注意：在实现上，worker thread 在执行自己队列任务时，不总是 LIFO 方式，可以通过构造函数修改成 FIFO 方式） g-4 关于双向队列 12345双向队列在实现方面的主要挑战是“同步”和“its avoidance（不知道怎么翻译）”。即使JVM优化了同步功能，每次 push 和 pop 时都要获取锁的这种操作，也会变成瓶颈。但是，一些策略的改变，提供了一种解决方案：push 和 pop 操作，只针对本线程内的队列。“偷取”操作可以很方便地通过一个“偷取锁”，来进行限制（双向锁在情况需要时，也可以使“偷取”操作失效）。因此，在队列两端的同步问题上的控制操作，就会减少。当双向队列要变成空时，可以对pop 或“偷取”操作进行控制。不然，这两个操作要被担保，可以操作disjoint elements of the array","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://raoyangsheng.com/tags/JAVA/"}]},{"title":"问题记录-Mysql 1449 The user specified as a definer ('root'@'%') does not exist 解决方法","slug":"it-db-mysql-01","date":"2015-10-04T11:18:31.000Z","updated":"2019-12-05T06:12:56.150Z","comments":true,"path":"2015/10/it-db-mysql-01.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-db-mysql-01.html","excerpt":"","text":"最近做项目是将线上数据库导入到本地localhost后程序调用视图时报mysql 1449错误。 问题说明：12345从一个数据库数据迁移到本地localhost程序在调用到数据库的视图时报错，直接在数据库中打开视图时也报错，类似：mysql 1449 ： The user specified as a definer (&apos;montor&apos;@&apos;%&apos;) does not exist经查，是权限问题，解决办法 授权 给 root 所有sql 的权限。 如图所示 解决问题：123456781，授权 给 root 所有sql 权限;2，运行：grant all privileges on *.* to monitor@&quot;%&quot; identified by &quot;.&quot;;mysql&gt; grant all privileges on *.* to root@&quot;%&quot; identified by &quot;.&quot;;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec) 最后打开视图时便不会报错，程序调用也不会报错。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://raoyangsheng.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://raoyangsheng.com/tags/MySQL/"}]},{"title":"解决eclipse中git插件中的cannot open git-upload-pack问题","slug":"it-java-tool-02","date":"2015-10-02T23:15:22.000Z","updated":"2019-12-05T06:12:56.153Z","comments":true,"path":"2015/10/it-java-tool-02.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-java-tool-02.html","excerpt":"","text":"最近使用Eclipse向git同步代码时，出现cannot open git-upload-pack这个问题，后来找资料发现是Eclipse中git插件的配置问题。 下面是处理方法：1):打开eclipse中的windows--&gt;Preferences--&gt;Team--&gt;Git--&gt;Configuration--&gt;User Settings.2):然后点Add Entry新建一个键值对，输入http.sslVerify=false 如图所示: 然后确定即可解决问题，之后就发现git可以正常的pull和push了。","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://raoyangsheng.com/tags/Git/"}]},{"title":"jvisualvm监控远程SpringBoot应用","slug":"it-java-tool-01","date":"2015-10-02T23:12:36.000Z","updated":"2019-12-05T06:12:56.152Z","comments":true,"path":"2015/10/it-java-tool-01.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-java-tool-01.html","excerpt":"","text":"使用Java自带jvisualvm工具来监控远程SpringBoot应用的运行情况步骤 第一步骤：增加启动参数配置：通常SpringBoot应用启动方式为： java -jar springboot应用.jar 远程监控命令在java 与-jar之间增加，如下：java -Djava.rmi.server.hostname=10.0.0.222 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=60001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar springboot应用.jar 即可 格式化后如下：1234567java \\-Djava.rmi.server.hostname=10.0.0.222 \\-Dcom.sun.management.jmxremote \\-Dcom.sun.management.jmxremote.port=60001 \\-Dcom.sun.management.jmxremote.authenticate=false \\-Dcom.sun.management.jmxremote.ssl=false \\-jar springboot应用.jar 是不是觉得启动参数太长了，可以在系统环境变量中配置这些参数，如在/etc/profile 最后一行增加：12export JAVA_OPTS=&apos;-Djava.rmi.server.hostname=10.0.0.222 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=60001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false&apos;执行 source /etc/profile ，是环境变量立马生效； 配置完环境变量后，只需执行如下命令即可完成远程监控：java $JAVA_OPTS -jar springboot应用.jar 第二步骤：配置jvisualvma，添加远程主机： b，右键已添加的远程主机，添加JMX连接，如图： c，点击确定即可完成配置 d，最后双击已经填好的JMX连接，就能监控到cpu、堆、类、线程的使用情况，如下图： 看到上图表示配置成功。","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://raoyangsheng.com/tags/SpringBoot/"}]},{"title":"Zookeeper 集群搭建","slug":"it-backend-zk-01","date":"2015-10-02T09:59:11.000Z","updated":"2019-12-05T06:12:56.150Z","comments":true,"path":"2015/10/it-backend-zk-01.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-backend-zk-01.html","excerpt":"","text":"如近分布式架构常用\b到Zookeeper组建，下面来介绍下Zookeeper集群的搭建方法 第一步：下载并上传zookeeper-3.4.6.tar.gz到各个服务器的/usr/local/目录,或者使用wget命令123cd /usr/local/wget http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gztar -zxvf zookeeper-3.4.6.tar.gz 第二步：在各个服务器上解压zookeeper安装包，并按节点号对zookeeper目录重命名123456# 服务器1cp -r zookeeper-3.4.6 zookeeper-3.4.6_1# 服务器2cp -r zookeeper-3.4.6 zookeeper-3.4.6_2# 服务器3cp -r zookeeper-3.4.6 zookeeper-3.4.6_3 第三步：在各zookeeper节点目录下创建以下目录123456789cd /usr/local/zookeeper-3.4.6_1mkdir datamkdir logscd /usr/local/zookeeper-3.4.6_2mkdir datamkdir logscd /usr/local/zookeeper-3.4.6_3mkdir datamkdir logs 第四步：将各节点zookeeper/zookeeper-3.4.6_x/conf目录下的zoo_sample.cfg文件拷贝一份，命名为zoo.cfg123456cd /usr/local/zookeeper-3.4.6_1/confcp zoo_sample.cfg zoo.cfgcd /usr/local/zookeeper-3.4.6_2/confcp zoo_sample.cfg zoo.cfgcd /usr/local/zookeeper-3.4.6_3/confcp zoo_sample.cfg zoo.cfg 第五步：修改 zoo.cfg 配置文件12345678910111213141516171819202122232425262728293031323334353637cd /usr/local/zookeeper-3.4.6_1/conf# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_1/datadataLogDir=/usr/local/zookeeper-3.4.6_1/logsclientPort=2181server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883# -----------------------------------cd /usr/local/zookeeper-3.4.6_2/confvi zoo.cfg# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_2/datadataLogDir=/usr/local/zookeeper-3.4.6_2/logsclientPort=2182server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883# -----------------------------------cd /usr/local/zookeeper-3.4.6_3/confvi zoo.cfg# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_3/datadataLogDir=/usr/local/zookeeper-3.4.6_3/logsclientPort=2183server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883 第六步：在dataDir=/usr/local/zookeeper-3.4.6_x/data下创建 myid 文件123vi /usr/local/zookeeper-3.4.6_1/data/myid #设置值为1vi /usr/local/zookeeper-3.4.6_2/data/myid #设置值为2vi /usr/local/zookeeper-3.4.6_3/data/myid #设置值为3 第七步：启动并查看zookeeper1234cd /usr/local/usr/local/zookeeper-3.4.6_1/bin/zkServer.sh start/usr/local/zookeeper-3.4.6_2/bin/zkServer.sh start/usr/local/zookeeper-3.4.6_3/bin/zkServer.sh start 第八步：验证zookeeper启动情况123/usr/local/zookeeper-3.4.6_1/bin/zkServer.sh status/usr/local/zookeeper-3.4.6_2/bin/zkServer.sh status/usr/local/zookeeper-3.4.6_3/bin/zkServer.sh status 第九步：如果启动成功，三台机器结果类似如下,标红部分为一个leader,两个follower123456789101112[root@centos7 local]# /usr/local/zookeeper-3.4.6_1/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_1/bin/../conf/zoo.cfgMode: &quot;follower&quot;[root@centos7 local]# /usr/local/zookeeper-3.4.6_2/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_2/bin/../conf/zoo.cfgMode: &quot;leader&quot;[root@centos7 local]# /usr/local/zookeeper-3.4.6_3/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_3/bin/../conf/zoo.cfgMode: &quot;follower&quot; 此时zookeeper集群搭建成功。","categories":[{"name":"后端","slug":"后端","permalink":"https://raoyangsheng.com/categories/后端/"}],"tags":[{"name":"Zookeeper","slug":"Zookeeper","permalink":"https://raoyangsheng.com/tags/Zookeeper/"},{"name":"集群","slug":"集群","permalink":"https://raoyangsheng.com/tags/集群/"}]},{"title":"Linux下如何释放cache内存(drop_caches)","slug":"it-linux-03","date":"2015-10-01T12:11:12.000Z","updated":"2019-12-05T06:12:56.154Z","comments":true,"path":"2015/10/it-linux-03.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-linux-03.html","excerpt":"","text":"最近使用的linux系统内存缓存越来越大，free内存越来越小，后来从网上找到资料完美解决。 第1步：执行 cat /proc/sys/vm/drop_caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存）第2步：执行sync命令，手动执行sync命令（描述：sync 命令运行 sync 子例程。如果必须停止系统，则运行 sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件）第3步：执行echo 3 &gt;&gt; /proc/sys/vm/drop_caches 命令，将drop_caches值改成3。此时已经完成，可执行 free -m 命令查看是否生效。 如图：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/tags/Linux/"}]},{"title":"Linux修改主机名称、DNS解析","slug":"it-linux-02","date":"2015-10-01T11:22:32.000Z","updated":"2019-12-05T06:12:56.153Z","comments":true,"path":"2015/10/it-linux-02.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-linux-02.html","excerpt":"","text":"Linux修改主机名称、DNS解析步骤 inux更改主机名称：12345678vi /etc/sysconfig/network打开配置文件设置HOSTNAME=hadoop(自己想更改的名称)退出保存即可测试：重启机器 设置DNS域名解析：12345678vi /etc/hosts打开配置文件在最后加入：ip地址 域名称（192.168.110.101 hadoop）保存退出即可测试：ping hadoop 设置ip地址：12345678查看ip地址：ifconfig修改ip地址：vi /etc/sysconfig/network-scripts/ifcfg-eth0 打开配置文件设置ip地址，网关、域名等保存退出，执行命令：service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/tags/Linux/"}]},{"title":"Linux下关闭防火墙","slug":"it-linux-01","date":"2015-10-01T11:13:42.000Z","updated":"2019-12-05T06:12:56.153Z","comments":true,"path":"2015/10/it-linux-01.html","link":"","permalink":"https://raoyangsheng.com/2015/10/it-linux-01.html","excerpt":"","text":"Linux下关闭防火墙步骤 步骤如下：1234567891、首先使用chkconfig --list iptables查看防火墙（服务）的状态 [ 查看指定的服务状态：chkconfig --list 服务名 ]2、可以看到服务的各个级别的启动状态（应该有6个级别）3、执行命令chkconfig iptables off 永久性关闭防火墙（在此处我们不是单独的关闭某一个级别的状态，而是关闭所有级别）4、执行命令chkconfig iptables on开启防火墙","categories":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://raoyangsheng.com/tags/Linux/"}]}]}